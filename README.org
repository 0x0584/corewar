#+TITLE: Virtual machine. Interpret byte-code.
#+AUTHOR: Anas Rchid

* Abstract

#+BEGIN_QUOTE
The /VM/ reads a byte-code generated by the compiler. It has a well defined structure that's built upon operations (OPs) and their parameters. The /VM/ serve as an arena in which /champions/ are loaded into a shared memory resource. In which the players /execute/ operation for the purpose dis-functioning other players.

Thenceforth, the last player that was declared /alive/ wins as the game terminates when all players are dead.
#+END_QUOTE

* Assembly Language

** Operations and Instructions

There are 16 different operations. Each of which has a unique =op_code=, or Operation Code. Some create processes (=fork=), while others resemble the ALU (Arithmetic and Logical Unit: =add=, =sub=, =and=, =or= and =xor=). Also manipulating the memory using =ld= and =st=. Also we can perform a jump to a specific place in the memory using =zjmp=. And we can print a character using =aff=.


An instruction is a operation with parameters. The Byte-code corresponding to each instruction have the following schema

#+BEGIN_QUOTE
=<OP_CODE> <ENCODING_BYTE> <PARAMETERS>=
#+END_QUOTE

*** ALU

- =add=        :: /takes three registers/, adds the first two and puts the result into the last one. *sets the carry to 1 if the result was 0*
- =sub=        ::  /takes three registers/, subtracts the second from the first, and puts the result into the last one. *sets the carry to 1 if the result was 0*
- =and/or/xor= :: /takes two arguments and a register/, apply bitwise operation to the two arguments and place the result into the last one. *sets the carry to 1 if the result was 0*

*** Process Creation

- =fork=  :: /takes a direct argument/, creates a new child process of the callee.
- =lfork= :: same as =fork=, except it uses absolute memory addressing.

*** Memory manipulation

- =ld=   :: /takes address and a register/, loads the value from the address into the register.
- =st=   :: /takes a register and an address/, sets the value of the register into the address.
- =ldi=  :: /takes two addresses and a register/, sums them up and then load the value in the result address into the register.
- =sti=  :: /takes a register and two addresses/, sums them up and set the value of the register into the resulted address.
- =zjmp= :: /takes a address/ and it jumps to that address. (change *PC*)

** Arguments and Parameter Encoding

- register arguments :: prefixed with /r/, takes 1B of memory for encoding, 4 Bytes storage.
- direct arguments   :: prefixed with /%/, takes 4B of memory.
- indirect arguments :: passed literally, takes 2B of memory.

To indicate the different types of arguments, we encode each type spesifically. Thus we have

- register :: =0b01=
- direct   :: =0b10=
- indirect :: =0b11=

And since operations takes at most 3 parameters, the /encoding byte/ is always suffixed with =0b00=

** Compilation
*** Byte-code
*** Labels

* Memory

We have 4KB of memory, and each player is loaded into a page in the memory where all pages are separated equivalently. All operations address a memory address relative to a page --- /module page size/. Except of long operations (=lfork=, =lld=, =lldi=), these address the absolute memory range.

* The /fetch-decode-execute/ Cycle

after reading the header, all what's left is the instructions that we would execute. instructions are operations with parameters.

* References

- [[https://github.com/k-off/Corewar/wiki/Virtual_machine][CookBook]]
- [[https://en.wikibooks.org/wiki/Core_War][Wikibooks]]
