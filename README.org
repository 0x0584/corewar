#+TITLE: Virtual machine. Interpret byte-code.
#+AUTHOR: Anas Rchid

* Abstract

#+BEGIN_QUOTE
The /VM/ reads a byte-code generated by the compiler. It has a well defined structure that's built upon operations (OPs) and their parameters. The /VM/ serve as an arena in which /champions/ are loaded into a shared memory resource. In which the players /execute/ operation for the purpose dis-functioning other players. Thenceforth, the last player that was declared /alive/ wins as the game terminates when all players are dead.
#+END_QUOTE

* Memory

We have 4KB of memory, and each player is loaded into a page in the memory where all pages are separated equivalently.

All operations address a memory address relative to a page---/module page size/. Except of long operations, these address the absolute memory range.

* Assembly Language

** Operations

There are 16 different operations. Some create processes (=fork=), while others resemble the ALU (Arithmetic and Logical Unit, =add=, =sub=, =and=, =or= and =xor=). Also manipulating the memory using =ld= and =st=. Also we can perform a jump to a specific place in the memory using =zjmp=. And we can print a character using =aff=.

*** ALU

- =add= :: /takes three registers/, adds the first two and puts the result into the last one. *sets the carry to 1 if the result was 0*
- =sub= ::  /takes three registers/, subtracts the second from the first, and puts the result into the last one. *sets the carry to 1 if the result was 0*
- =and/or/xor= :: /takes two arguments and a register/, apply bitwise operation to the two arguments and place the result into the last one. *sets the carry to 1 if the result was 0*

*** Process Creation

- =fork= :: /takes a direct argument/, creates a new child process of the callee. it has a long version =lfork=, the later is absolute adressing.

*** Memory manipulation

** Arguments

** Compilation
