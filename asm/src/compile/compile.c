/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   compile.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: archid- <archid-@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/02/19 15:25:02 by archid-           #+#    #+#             */
/*   Updated: 2021/03/15 14:41:14 by archid-          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "compile.h"
#include "op_impl.h"

static t_st		write_champion(const int fd, const char *outname)
{
	int		magic;
	int		prog_size;
	int		null;

	magic = beword(COREWAR_EXEC_MAGIC);
	prog_size = beword(g_champ.prog_size);
	null = 0;
	write(fd, &magic, sizeof(int));
	write(fd, g_name, PROG_NAME_LENGTH);
	write(fd, &null, sizeof(int));
	write(fd, &prog_size, sizeof(int));
	write(fd, g_champ.comment, COMMENT_LENGTH);
	write(fd, &null, sizeof(int));
	write(fd, g_champ.file, g_champ.prog_size);
	ft_dprintf(2, "%{green_fg}wrote %s%{reset}\n", outname);
	return (st_succ);
}

t_st			compile(t_lst lines, const char *outname)
{
	t_lst			ops;
	t_st			st;
	int				fd;

	if ((fd = open(outname, O_CREAT | O_TRUNC | O_WRONLY, 0777)) < 0)
	{
		ft_dprintf(2, "cannot open file descriptor for writing %s!\n", outname);
		return (st_error);
	}
	else if (!lst_empty(lines) && (ops = parse_ops(lines)))
	{
		if ((st = write_prog(ops)) == st_succ)
			st = write_champion(fd, outname);
		lst_del(&ops);
	}
	else
		st = st_error;
	close(fd);
	return (st);
}

static void		substitute_label(void *blob, void *st)
{
	t_op			*op;
	t_op			*label;
	t_arg			arg;
	t_s16			offset;

	if (*(t_st *)st != st_succ)
		return ;
	arg = 0;
	op = blob;
	offset = op->addr + (op->info.meta.of.encoded != 0) + 1;
	while (arg < op->info.nargs)
	{
		if (op->labels[arg])
		{
			if ((label = hash_get(g_labels, op->labels[arg], NULL)))
			{
				op->info.args.c[arg].short_chunk = label->addr - op->addr;
				write_arg(&op->info, arg, offset);
			}
			else
			{
				ft_dprintf(2, "referencing unknown label %s\n",
							op->labels[arg]);
				*(t_st *)st = st_error;
				break ;
			}
		}
		offset += arg_offset(&op->info, arg++);
	}
}

t_st			write_prog(t_lst ops)
{
	t_s16			size;
	t_st			st;

	size = 0;
	lst_iter_arg(ops, true, &size, write_op);
	if (size == -1)
	{
		ft_dprintf(2, "The generated byte-code exceeds "
						"the program size limit %d\n",
						CHAMP_MAX_SIZE);
		return (st_error);
	}
	g_champ.prog_size = size;
	st = st_succ;
	lst_iter_arg(ops, true, &st, substitute_label);
	return (st);
}
