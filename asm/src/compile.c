/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   compile.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: archid- <archid-@student.1337.ma>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/02/19 15:25:02 by archid-           #+#    #+#             */
/*   Updated: 2021/02/19 16:13:07 by archid-          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "parser.h"
#include "op_impl.h"

static int i = 0;

static void		dump_line(void *blob)
{
	ft_printf(" line %d `%s`\n", i++, blob);
}

t_st			compile(t_lst lines, const char *outname)
{
	t_lst			ops;
	t_st			st;

	lst_iter(lines, true, dump_line);
	if ((ops = parse_ops(lines)))
	{
		st = write_prog(ops, outname);
		lst_del(&ops);
		return st;
	}
	else
	{
		return st_error;
	}
}

static t_u8		op_memory_footprint(const t_op *op)
{
	t_u8			size;
	t_arg			arg;
	t_arg			type;

	size = 1;
	if (op->info.meta.of.encoded)
		size += 1;
	arg = 0;
	while (arg < op->info.nargs)
		if ((type = encoded(op_encoding(&op->info, arg++))) == T_REG)
			size += 1;
		else if (type == T_DIR)
			size += op->info.meta.of.short_chunk ? IND_SIZE : REG_SIZE;
		else
			size += IND_SIZE;
	return (size);
}

static void		substitute_label(const char *key, void *blob)
{
	t_op			*op;

	op = blob;

}

static void		write_arg(const t_op_info *info, const t_arg arg, t_s16 *at)
{
	t_s16			i;
	t_arg			type;

	i = *at;
	if ((type = encoded(op_encoding(info, arg))) == T_REG)
		g_champ.file[i++] = info->args.v[arg];
	else if (type == T_DIR && info->meta.of.short_chunk)
	{
		g_champ.file[i++] = info->args.c[arg].val.byte_1;
		g_champ.file[i++] = info->args.c[arg].val.byte_2;
		g_champ.file[i++] = info->args.c[arg].val.byte_3;
		g_champ.file[i++] = info->args.c[arg].val.byte_4;
	}
	else
	{
		g_champ.file[i++] = info->args.c[arg].val.byte_1;
		g_champ.file[i++] = info->args.c[arg].val.byte_2;
	}
	*at = i;
}

static void		write_args(const t_op *op, t_s16 *size)
{
	t_arg			arg;

	arg = 0;
	while (arg < op->info.nargs)
		write_arg(&op->info, arg++, size);
}

static void		write_op(void *blob, void *size)
{
	const t_op		*op;
	t_s16			at;

	if (!(op = blob) || (at = *(t_s16 *)size) < 0)
		return ;
	else if ((at + op_memory_footprint(op)) < CHAMP_MAX_SIZE)
	{
		g_champ.file[at++] = op->info.code;
		g_champ.file[at++] = op->info.encoded.encod;
		write_args(op, size);
	}
	else
		*(t_s16 *)size = -1;
}

t_st			write_prog(t_lst ops, const char *out)
{
	t_s16			size;

	size = 0;
	lst_iter_arg(ops, true, &size, write_op);
	if (size == -1)
	{
		ft_dprintf(2, "The generated byte-code exceeds the program size limit %d\n",
				   CHAMP_MAX_SIZE);
		return st_error;
	}
	return (st_succ);
}
